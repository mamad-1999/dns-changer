package main

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"net/http"
	"os"
	"os/exec"
	"path/filepath"
	"strings"

	"github.com/fatih/color"
	"github.com/rodaine/table"
)

const configURL = "https://raw.githubusercontent.com/mamad-1999/dns-changer/refs/heads/master/config.json" // Update the URL as needed

type DnsConfig struct {
	Name    string   `json:"name"`
	Servers []string `json:"servers"`
}

// Function to ping a DNS server with a custom timeout and return the result
func pingDns(server string) string {
	cmd := exec.Command("ping", "-c", "1", "-W", "2", server) // -W 2 sets the timeout to 2 seconds
	output, err := cmd.CombinedOutput()

	if err != nil {
		return "unreachable"
	}

	// Parse the output to get the response time
	outputStr := string(output)
	lines := strings.Split(outputStr, "\n")
	for _, line := range lines {
		if strings.Contains(line, "time=") {
			parts := strings.Split(line, "time=")
			return fmt.Sprintf("%s ", parts[1])
		}
	}
	return "unknown"
}

func displayDnsOptions(dnsConfigs []DnsConfig) {
	// Create a new table with headers
	t := table.New("", "DNS Server", "Ping Time")

	// Add rows with line number, DNS server names, and ping results
	color.Yellow("I am pinging the DNS server, please wait 2 seconds...")

	for i, config := range dnsConfigs {
		pingResult := pingDns(config.Servers[0]) // Assume the first server is used for pinging
		// Add a gap (e.g., 4 spaces) between columns by formatting each column's data
		t.AddRow(fmt.Sprintf("%d", i+1), fmt.Sprintf("%-15s", config.Name), fmt.Sprintf("%-20s", pingResult))
	}

	// Print the table with a horizontal line before the table
	t.Print()

	// Add exit option
	fmt.Println("0. Exit")
}

func buildResolvContent(config DnsConfig) string {
	var resolvContent strings.Builder
	resolvContent.WriteString("# Generated by Dns-changer\n")
	for _, server := range config.Servers {
		resolvContent.WriteString(fmt.Sprintf("nameserver %s\n", server))
	}
	return resolvContent.String()
}

func downloadConfig(path string) error {
	resp, err := http.Get(configURL)
	if err != nil {
		return err
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return fmt.Errorf("failed to download config: %s", resp.Status)
	}

	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return err
	}

	return ioutil.WriteFile(path, body, 0644)
}

func writeToResolv(content string) error {
	cmd := exec.Command("sudo", "sh", "-c", fmt.Sprintf("echo '%s' > /etc/resolv.conf", content))
	return cmd.Run()
}

func main() {
	homeDir, err := os.UserHomeDir()
	if err != nil {
		color.Red("Error finding home directory: %s", err)
		return
	}

	configDir := filepath.Join(homeDir, ".config", "dns-changer")
	configPath := filepath.Join(configDir, "config.json")

	// Ensure the config directory exists
	if _, err := os.Stat(configDir); os.IsNotExist(err) {
		if err := os.MkdirAll(configDir, 0755); err != nil {
			color.Red("Error creating config directory: %s", err)
			return
		}
	}

	// Check if config.json exists locally
	if _, err := os.Stat(configPath); os.IsNotExist(err) {
		color.Yellow("config.json not found locally. Downloading from GitHub...")
		if err := downloadConfig(configPath); err != nil {
			color.Red("Error downloading config.json: %s", err)
			return
		}
	}

	// Read the config.json file
	data, err := ioutil.ReadFile(configPath)
	if err != nil {
		color.Red("Error reading %s: %s", configPath, err)
		return
	}

	var dnsConfigs []DnsConfig
	if err := json.Unmarshal(data, &dnsConfigs); err != nil {
		color.Red("Error parsing JSON: %s", err)
		return
	}

	// Display the DNS servers with ping results
	displayDnsOptions(dnsConfigs)

	// Get user input
	var choice int
	fmt.Print("Select a DNS server by number: ")
	fmt.Scan(&choice)

	if choice == 0 {
		color.Green("Exiting the program.")
		return
	}

	if choice < 1 || choice > len(dnsConfigs) {
		color.Red("Invalid choice. Please run the program again.")
		return
	}

	// Build the resolv.conf content
	selectedConfig := dnsConfigs[choice-1]
	resolvContent := buildResolvContent(selectedConfig)

	// Write to /etc/resolv.conf with sudo
	if err := writeToResolv(resolvContent); err != nil {
		color.Red("Error writing to /etc/resolv.conf: %s", err)
		return
	}

	color.Green("Successfully changed DNS to %s", selectedConfig.Name)
}
