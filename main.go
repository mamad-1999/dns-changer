package main

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"net/http"
	"os"
	"os/exec"
	"path/filepath"
	"strings"

	"github.com/fatih/color"
)

const configURL = "https://raw.githubusercontent.com/mamad-1999/dns-changer/refs/heads/master/config.json" // Update the URL as needed

type DnsConfig struct {
	Name    string   `json:"name"`
	Servers []string `json:"servers"`
}

func main() {
	homeDir, err := os.UserHomeDir()
	if err != nil {
		color.Red("Error finding home directory: %s", err)
		return
	}

	configDir := filepath.Join(homeDir, ".config", "dns-changer")
	configPath := filepath.Join(configDir, "config.json")

	// Ensure the config directory exists
	if _, err := os.Stat(configDir); os.IsNotExist(err) {
		if err := os.MkdirAll(configDir, 0755); err != nil {
			color.Red("Error creating config directory: %s", err)
			return
		}
	}

	// Check if config.json exists locally
	if _, err := os.Stat(configPath); os.IsNotExist(err) {
		color.Yellow("config.json not found locally. Downloading from GitHub...")
		if err := downloadConfig(configPath); err != nil {
			color.Red("Error downloading config.json: %s", err)
			return
		}
	}

	// Read the config.json file
	data, err := ioutil.ReadFile(configPath)
	if err != nil {
		color.Red("Error reading %s: %s", configPath, err)
		return
	}

	var dnsConfigs []DnsConfig
	if err := json.Unmarshal(data, &dnsConfigs); err != nil {
		color.Red("Error parsing JSON: %s", err)
		return
	}

	// Display the DNS servers
	displayDnsOptions(dnsConfigs)

	// Get user input
	var choice int
	fmt.Print("Select a DNS server by number: ")
	fmt.Scan(&choice)

	if choice == 0 {
		color.Green("Exiting the program.")
		return
	}

	if choice < 1 || choice > len(dnsConfigs) {
		color.Red("Invalid choice. Please run the program again.")
		return
	}

	// Build the resolv.conf content
	selectedConfig := dnsConfigs[choice-1]
	resolvContent := buildResolvContent(selectedConfig)

	// Write to /etc/resolv.conf with sudo
	if err := writeToResolv(resolvContent); err != nil {
		color.Red("Error writing to /etc/resolv.conf: %s", err)
		return
	}

	color.Green("Successfully changed DNS to %s", selectedConfig.Name)
}

func displayDnsOptions(dnsConfigs []DnsConfig) {
	fmt.Println("Available DNS Servers:")
	for i, config := range dnsConfigs {
		color.Yellow("%d. %s", i+1, config.Name)
	}
	color.Yellow("0. Exit")
}

func buildResolvContent(config DnsConfig) string {
	var resolvContent strings.Builder
	resolvContent.WriteString("# Generated by Dns-changer\n")
	for _, server := range config.Servers {
		resolvContent.WriteString(fmt.Sprintf("nameserver %s\n", server))
	}
	return resolvContent.String()
}

func downloadConfig(path string) error {
	resp, err := http.Get(configURL)
	if err != nil {
		return err
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return fmt.Errorf("failed to download config: %s", resp.Status)
	}

	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return err
	}

	return ioutil.WriteFile(path, body, 0644)
}

func writeToResolv(content string) error {
	cmd := exec.Command("sudo", "sh", "-c", fmt.Sprintf("echo '%s' > /etc/resolv.conf", content))
	return cmd.Run()
}
